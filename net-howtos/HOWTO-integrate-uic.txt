Hello!

I see many people here ask how to integrate Qt designer support, but
nobody reported success.  I could do it for a project called qgit (Qt
frontend to git, the version control system used by the Linux kernel).

I was able to test the project on FreeBSD with the native BSD make, and
there were no errors concerning the makefiles.

Here's the src/Makefile.am from qgit with the actual sources replaced
with short placeholders and without irrelevant extra targets:

-------------- 
bin_PROGRAMS = foo
DISTSOURCES = foo.cpp
DISTHEADERS_MOC = bar.h
DISTHEADERS_NO_MOC = baz.h
FORMS = quux.ui

FORMHEADERS = $(FORMS:.ui=.h)
MOC_CC = $(FORMS:.ui=.moc.cc) $(DISTHEADERS_MOC:.h=.moc.cc)
UIC_CC = $(FORMS:.ui=.uic.cc)

BUILT_SOURCES = $(FORMHEADERS) $(UIC_CC) $(MOC_CC)
CLEANFILES = $(BUILT_SOURCES)
EXTRA_DIST = $(FORMS)

foo_SOURCES = $(DISTSOURCES) $(DISTHEADERS_MOC) $(DISTHEADERS_NO_MOC)
nodist_foo_SOURCES = $(MOC_CC) $(UIC_CC)

.ui.h:
        $(QT_UIC) -o $@ $<

.h.moc.cc:
        $(QT_MOC) -o $@ $<

.h.uic.cc:
        $(QT_UIC) -o $@ -impl $< $(srcdir)/$(<:.h=.ui)

SUFFIXES = .h .ui .moc.cc .uic.cc
--------------

As you can see, I'm using double extensions so that syntax rules can be
used both for generating and for compiling generated sources.  It's
probably not necessary to use *.cpp for real sources and *.cc for
generated ones, but it's convenient to distinguish them.

While I want to share my positive experience, I'd like to hear from the
Automake gurus if I'm doing something potentially problematic, in
particular:

- How portable are double extensions? (I'm more concerned about UNIX
make issues than about MS DOS)

- How portable is $(<:.h=.ui) in the suffix rules?

- How safe are substitution references like $(FORMS:.ui=.h) in Automake
variables?  Does Automake calculate them (I guess it does, but keeps the
original line in Makefile.in)?

I actually tried another approach without double extensions.  Real
sources end with .cpp, sources generated by uic end with .cc and sources
generated by moc end with .cxx (I chose standard extensions so that I
won't need to force-feed them to the compiler as C++ sources).  *.cc is
compiled to libuic.a with a dummy per-target flag.  *.cxx is compiled to
libmoc.a with another dummy per-target flag.  They are linked with the
objects made from the real sources.  It worked too, but Makefile was
very large because it had rules for every file.

-- 
Regards,
Pavel Roskin



--------------------- QT web page -------------------------------


This page documents the User Interface Compiler for the Qt GUI toolkit.
The uic reads an XML format user interface definition (.ui) file as generated by Qt Designer and creates 
a corresponding C++ header file.

Usage:

 uic [options] <uifile>

Options

The following table lists the command-line options recognized by uic.
Option	Description
-o <file>	Write output to <file> instead of to standard output.
-tr <func>	Use <func> for translating strings instead of tr().
-p	Don't generate guards against multiple inclusion (#ifndef FOO_H ...).
-h	Display the usage and the list of options.
-v	Display uic's version number.
Examples

If you use qmake, uic will be invoked automatically for header files.

Here are useful makefile rules if you only use GNU make:

 ui_%.h: %.ui
         uic $< -o $@

If you want to write portably, you can use individual rules of the following form:

 ui_foo.h: foo.ui
         uic $< -o $@

You must also remember to add ui_foo.h to your HEADERS (substitute your favorite name).
